- [友元](#友元)
  - [友元函数](#友元函数)
  - [友元类](#友元类)
  - [友元函数和类的特点](#友元函数和类的特点)
  - [使用友元的场景](#使用友元的场景)
- [嵌套类](#嵌套类)
  - [嵌套类的特点](#嵌套类的特点)
  - [示例代码](#示例代码)

# 友元

> 在 C++ 中，**友元（Friend）**是一个非常特殊的概念，它使得某些非成员函数或其他类能够访问类的私有成员和保护成员。通常，私有成员和保护成员只能在类的成员函数内部访问，但通过将函数或类声明为友元，能够绕过这个访问限制。

## 友元函数

友元函数是一个普通的**非成员函数**，但它能够访问类的私有成员和保护成员。但**需要在类的内部声明**，声明时需要加`friend`关键字。

利用友元重载`<<`和`>>`

```cpp
class Date
{
public:
	friend istream& operator>>(istream& _cin, Date& d);// 友元函数
	friend ostream& operator<<(ostream& _cout, const Date& d);// 友元函数
	Date(int year = 0, int month = 1, int day = 1)
		:_year(year)
		, _month(month)
		, _day(day)
	{}

private:
	int _year;
	int _month;
	int _day;
};
//重载>>运算符
istream& operator>>(istream& _cin, Date& d)
{
	_cin >> d._year >> d._month >> d._day;
	return _cin;
}
// 重载<<运算符
ostream& operator<<(ostream& _cout, const Date& d)
{
	_cout << d._year << "-" << d._month << "-" << d._day;
	return _cout;
}
```

- 友元函数可以访问类的私有和保护成员，但**不是类的成员函数**
- 友元函数**不能用`const`修饰**
- 友元函数可以在类定义的任何地方声明，**不受类访问限定符限制**
- 一个函数可以是多个类的友元函数
- 友元函数的调用与普通函数的调用和原理相同

## 友元类

友元类是指某个类可以访问另一个类的私有和保护成员。这是通过在类内声明另一个类为友元来实现的。

```cpp
class ClassB;  
class ClassA {
    friend class ClassB;  // 声明 ClassB 为友元类

private:
    int data;
public:
    ClassA() : data(20) {}
};

class ClassB {
public:
    void printData(ClassA& obj) {
        cout << "ClassA data: " << obj.data << endl;  // 可以访问 ClassA 的私有成员
    }
};
```

在这个例子中，`ClassB` 被声明为 `ClassA` 的友元类，因此 `ClassB` 可以访问 `ClassA` 的私有成员 `data`，即使 `data` 是私有的。其他的类则不能访问 `ClassA` 的私有成员。

## 友元函数和类的特点

- **友元是单向的**：如果 `A` 是 `B` 的友元，`B` 并不是 `A` 的友元。友元关系是单向的，也就是说，只有声明了友元关系的一方才拥有访问权限。
- **友元关系并不传递**：如果 `A` 是 `B` 的友元，`B` 是 `C` 的友元，`A` 并不自动成为 `C` 的友元。友元关系不会传播。
- **友元不受访问控制的影响**：友元函数可以访问类的私有成员和保护成员，突破了封装性的限制。它们允许访问被视为“私密”的数据。

## 使用友元的场景

**需要访问类的私有数据的外部函数**：

- 当一个非成员函数需要访问类的私有成员时，可以通过友元函数来实现。比如，运算符重载、全局函数等。

**操作符重载**：

- 在进行运算符重载时，如果需要访问类的私有成员变量，通常可以将运算符重载函数声明为友元。

**访问类的私有成员的类**：

- 当某个类需要访问另一个类的私有成员时，可以通过将该类声明为友元类来实现。例如，一个类可能需要访问另一个类的内部数据。



# 嵌套类

> C++中的嵌套类是指在一个类的内部定义的另一个类。嵌套类可以像普通类一样定义和使用，它们与外部类有一定的关系，但也有一些独立性。

## 嵌套类的特点

1. **嵌套类可以访问外部类的私有成员**
    嵌套类可以通过外部类的对象来访问外部类的成员（包括私有成员），但它不能直接访问外部类的成员，除非它通过外部类对象来间接访问。

2. **嵌套类是独立的类**
    尽管它定义在外部类内部，但嵌套类是一个独立的类，可以在外部类之外创建对象。它与外部类没有直接的成员关系，除非外部类显式地提供访问。

3. **访问权限**
    嵌套类的访问权限通常是私有的，只有外部类的成员函数才能访问嵌套类，但如果需要，也可以将嵌套类设为公有，供外部使用。

4. **外部类的实例化不依赖于嵌套类**
    外部类的实例化与嵌套类无关，嵌套类的实例化可以独立于外部类。

5. **嵌套类可以直接访问外部类的静态成员**

   静态成员不依赖于类的实例，属于整个类的所有对象（包括嵌套类）。

## 示例代码

```cpp
#include <iostream>
using namespace std;

class Outer {
private:
    int outerData;
    static int staticData;

public:
    Outer(int value) : outerData(value) {}

    // 嵌套类
    class Nested {
    public:
        void showData(const Outer& outer) {
            // 通过外部类对象访问外部类的私有成员
            cout << "Outer class data: " << outer.outerData << endl;
        }

        void showStaticData() {
            // 直接访问外部类的静态成员
            cout << "Outer class static data: " << staticData << endl;
        }
    };
};

int Outer::staticData = 20;

int main() {
    Outer outerObj(10);
    Outer::Nested nestedObj;
    nestedObj.showData(outerObj);  // 访问外部类的数据
    nestedObj.showStaticData();     // 访问外部类的静态数据

    return 0;
}
```

