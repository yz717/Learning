- [动态内存管理](#动态内存管理)
    - [`new` 操作符](#new-操作符)
    - [`delete` 操作符](#delete-操作符)
    - [`operator new`函数](#operator-new函数)
    - [`operator delete`函数](#operator-delete函数)
    - [`operator new[]` 和 `operator delete[]`](#operator-new-和-operator-delete)
    - [`new`和`delete`的实现原理](#new和delete的实现原理)
      - [内置类型](#内置类型)
      - [自定义类型](#自定义类型)
    - [malloc/free和new/delete的区别](#mallocfree和newdelete的区别)
- [内存对齐](#内存对齐)
  - [对齐的目的](#对齐的目的)
  - [结构体内存对齐规则](#结构体内存对齐规则)
  - [举例说明](#举例说明)

# 动态内存管理

在 C++ 中，`new` 和 `delete` 操作符用于动态内存管理，它们允许在堆上分配和释放内存。它们的用法如下：

### `new` 操作符

`new` 用于在堆上分配内存，它返回一个指向所分配内存块的指针。

**用法**：

- **内置类型**：

  ```cpp
  int* p = new int(5); // 申请一个int类型的内存空间，初始化为5
  *p = 10; // 给分配的内存赋值
  ```

  这里，`new int` 会在堆上分配一个 `int` 类型的内存，并返回指向该内存的指针。

  针对内置类型可以在类型后面接一个括号表示初值如`int* p = new int(5);`。

- **自定义类型（类类型）**：

  ```cpp
  class MyClass {
  public:
      int value;
  };
  
  MyClass* p = new MyClass; // 分配一个 MyClass 类型的对象
  p->value = 10; // 访问成员变量
  ```

  对于类类型，`new MyClass` 会在堆上分配一个 `MyClass` 类型的对象，并调用构造函数。

### `delete` 操作符

`delete` 用于释放由 `new` 分配的内存，避免内存泄漏。

**用法**：

- **内置类型**：

  ```cpp
  delete p; // 释放 int 类型内存
  ```

  这里，`delete` 会释放之前通过 `new` 分配的内存。

- **自定义类型（类类型）**：

  ```cpp
  delete p; // 释放 MyClass 类型对象
  ```

  `delete` 会释放 `new MyClass` 所分配的内存，并调用类的析构函数。

**总结**

**内置类型**：`new` 用于分配基本类型的内存，`delete` 释放它们。

**自定义类型**：`new` 分配类类型对象时，会调用**构造函数**，`delete` 会调用**析构函数**。

**数组**：使用 `new[]` 和 `delete[]` 分配和释放数组时，必须匹配。

对一个 `nullptr` 调用 `delete` 或 `delete[]` 是安全的，什么也不会发生。

```cpp
int* arr = new int[10]; // 分配一个大小为 10 的整数数组
delete[] arr; // 释放数组内存
```

### `operator new`函数

`operator new` 是 C++ 中的内存分配函数，用于在堆上分配内存。它的功能类似于标准库的 `malloc`，但是与 `new` 操作符不同，`operator new` 返回的是一个原始的指针，而不进行类型的构造。

**基本用法**：

```cpp
void* operator new(std::size_t size);
```

- **参数**：`size` 是需要分配的字节数。
- **返回值**：返回一个指向分配内存的指针，如果内存分配失败，通常会抛出 `std::bad_alloc` 异常。
- **实现**：实际通过`malloc`来申请空间，当`malloc`申请空间成功时直接返回，申请空间失败时，抛异常。

###  `operator delete`函数

`operator delete` 用于释放通过 `operator new` 分配的内存。它的作用与 `delete` 操作符类似，但不会调用对象的析构函数（在对象被销毁时，`delete` 会调用析构函数，而 `operator delete` 只是简单释放内存）。

**基本用法**：

```cpp
void operator delete(void* pointer);
```

- **参数**：`pointer` 是指向要释放内存的指针。
- **实现**：实际通过`free`来释放空间。

### `operator new[]` 和 `operator delete[]`

类似于 `new[]` 和 `delete[]` 操作符，`operator new[]` 和 `operator delete[]` 用于数组的内存分配和释放。

- `operator new[]`：在堆上分配一块内存来存储一个数组。
- `operator delete[]`：释放通过 `operator new[]` 分配的数组内存。

```cpp
void* operator new[](std::size_t size);
void operator delete[](void* pointer);
```

###  `new`和`delete`的实现原理

#### 内置类型

`new`和`malloc`，`delete`和`free`基本类似，不同的地方是：

- `malloc`申请失败时会返回`NULL`
- `new`申请失败时会抛异常

#### 自定义类型

- `new`
  1. 调用`operator new`函数申请空间
  2. 在申请的空间上执行构造函数
- `delete`
  1. 在空间上执行析构函数
  2. 调用`operator delete`函数释放空间

### malloc/free和new/delete的区别

共同点：都是从堆上申请空间，需要手动释放

不同点：

- `malloc`、`free`是函数，`new`、`delete`是操作符
- `malloc`申请的空间不会初始化，`new`可以初始化
- `malloc`申请空间时，需要手动计算空间大小并传递，`new`只需在其后跟上空间的类型即可
- `malloc`的返回值为`void*`, 在使用时必须强转，`new`不需要，因为`new`后跟的是空间的类型
- `malloc`申请空间失败时，返回的是`NULL`，因此使用时必须判空，`new`不需要，但是`new`需要捕获异常
- 申请自定义类型对象时，`malloc/free`只会开辟空间，不会调用构造函数与析构函数，而`new`在申请空间后会调用构造函数完成对象的初始化，`delete`在释放空间前会调用析构函数完成空间中资源的清理

# 内存对齐

> 在现代计算机体系结构中，为了提高 CPU 对内存的访问效率，数据通常要求按照某些特定的边界进行对齐。即数据的起始地址通常需要是某个特定数值的倍数。例如，对于 4 字节的整数，系统可能要求它存储在内存中 4 的倍数地址上。

## 对齐的目的

内存对齐的主要目的是提高 **内存访问效率** 和确保 **硬件访问内存时的正确性**。

- **提高内存访问效率**：确保处理器可以高效地访问内存数据，减少内存访问的延迟。
- **避免硬件访问错误**：防止某些架构下的未对齐访问引发硬件错误或异常。
- **优化处理器指令**：对齐的数据可以直接访问，而未对齐的数据则需要多次访问，导致指令复杂性增加。
- **节省总线带宽**：对齐数据有助于减少总线传输的次数，提高带宽利用效率。
- **硬件架构的支持**：某些硬件架构要求对齐的数据访问，以确保系统正常运行

## 结构体内存对齐规则

1. 第一个成员在与结构体偏移量为0的地址处。
2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
   注意：对齐数=编译器默认的一个对齐数与该成员大小的较小值。
   VS中默认的对齐数为8
3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是
   所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

## 举例说明

**例1：基本数据类型的对齐**

```cpp
#include <iostream>

struct MyStruct1 {
    char a;    // 1 字节
    int b;     // 4 字节
    short c;   // 2 字节
};

int main() {
    std::cout << "sizeof(char): " << sizeof(char) << std::endl;
    std::cout << "sizeof(int): " << sizeof(int) << std::endl;
    std::cout << "sizeof(short): " << sizeof(short) << std::endl;
    std::cout << "sizeof(MyStruct1): " << sizeof(MyStruct1) << std::endl;
    return 0;
}
```

**内存布局分析 (通常情况，假设int的对齐要求是4字节):**

1. `char a;`：占用1个字节。假设起始地址是 `0x00`。
   - 内存: `| a |`
   - 地址: `|0x00|`
2. `int b;`：`int` 类型通常大小为4字节，对齐要求也是4字节。为了让 `b` 的起始地址是4的倍数，编译器会在 `a` 后面填充3个字节的**padding**。
   - 内存: `| a | P | P | P | b | b | b | b |` (P 代表 padding)
   - 地址: `|0x00|0x01|0x02|0x03|0x04|0x05|0x06|0x07|`
   - `b` 的起始地址是 `0x04`，是4的倍数。
3. `short c;`：`short` 类型通常大小为2字节，对齐要求也是2字节。`b` 结束后的地址是 `0x08`，已经是2的倍数，所以 `c` 可以直接放在后面。
   - 内存: `| a | P | P | P | b | b | b | b | c | c |`
   - 地址: `|0x00|0x01|0x02|0x03|0x04|0x05|0x06|0x07|0x08|0x09|`
4. **结构体整体对齐**：`MyStruct1` 中最大的对齐要求是 `int b` 的4字节。所以 `MyStruct1` 的总大小必须是4的倍数。当前成员占用的总字节数是 `1 (a) + 3 (padding) + 4 (b) + 2 (c) = 10` 字节。为了满足整体4字节对齐，编译器会在末尾再填充2个字节。
   - 内存: `| a | P | P | P | b | b | b | b | c | c | P | P |`
   - 地址: `|0x00|0x01|0x02|0x03|0x04|0x05|0x06|0x07|0x08|0x09|0x0A|0x0B|`
   - 因此，`sizeof(MyStruct1)` 通常会是 **12** 字节。

**例2：改变成员顺序**

```cpp
#include <iostream>

struct MyStruct2 {
    char a;    // 1 字节
    short c;   // 2 字节
    int b;     // 4 字节
};

int main() {
    std::cout << "sizeof(MyStruct2): " << sizeof(MyStruct2) << std::endl;
    return 0;
}
```

**内存布局分析:**

1. `char a;`：占用1个字节。起始地址 `0x00`。
   - 内存: `| a |`
2. `short c;`：`short` 类型2字节，对齐要求2字节。为了让 `c` 的起始地址是2的倍数，在 `a` 后面填充1个字节。
   - 内存: `| a | P | c | c |`
   - 地址: `|0x00|0x01|0x02|0x03|`
   - `c` 的起始地址是 `0x02`。
3. `int b;`：`int` 类型4字节，对齐要求4字节。`c` 结束后的地址是 `0x04`，已经是4的倍数，所以 `b` 可以直接放在后面。
   - 内存: `| a | P | c | c | b | b | b | b |`
   - 地址: `|0x00|0x01|0x02|0x03|0x04|0x05|0x06|0x07|`
4. 结构体整体对齐：`MyStruct2` 中最大的对齐要求是 `int b` 的4字节。当前成员占用的总字节数是 `1 (a) + 1 (padding) + 2 (c) + 4 (b) = 8` 字节。8已经是4的倍数。
   - 因此，`sizeof(MyStruct2)` 通常会是 **8** 字节。

**可以看到，仅仅改变成员的声明顺序，结构体的大小就可能发生变化！** 这对于优化内存占用非常重要。**通常建议将对齐要求较高的成员放在前面。**

**例3：使用 `alignas` (C++11及以后)**

你可以使用 `alignas` 关键字来指定更严格的对齐要求。

```cpp
#include <iostream>
#include <cstddef> // For std::max_align_t

struct MyStruct3 {
    alignas(8) int a; // 要求 a 按 8 字节对齐
    char b;
};

struct MyStruct4 {
    char b;
    alignas(8) int a;
};


int main() {
    std::cout << "alignof(int): " << alignof(int) << std::endl; // 通常是 4
    std::cout << "sizeof(MyStruct3): " << sizeof(MyStruct3) << std::endl;
    std::cout << "alignof(MyStruct3): " << alignof(MyStruct3) << std::endl;
    std::cout << "Offset of b in MyStruct3: " << offsetof(MyStruct3, b) << std::endl;

    std::cout << "sizeof(MyStruct4): " << sizeof(MyStruct4) << std::endl;
    std::cout << "alignof(MyStruct4): " << alignof(MyStruct4) << std::endl;
    std::cout << "Offset of a in MyStruct4: " << offsetof(MyStruct4, a) << std::endl;
    return 0;
}
```

**内存布局分析 `MyStruct3`:**

1. `alignas(8) int a;`：`int` 大小仍为4字节，但其对齐要求被强制为8字节。起始地址 `0x00`。
   - 内存: `| a | a | a | a | P | P | P | P |` (即使a本身只占4字节，但为了满足8字节对齐的起始，它会“占据”一个8字节的块，如果后面紧跟的是另一个alignas(8)的成员，则可以直接放。但这里是char b)
   - 实际上，`a` 放在地址 `0x00`，占用4字节。
2. `char b;`：占用1字节。`a` 结束后地址是 `0x04`。`b` 可以直接放在后面。
   - 内存: `| a | a | a | a | b |`
   - 地址: `|0x00|0x01|0x02|0x03|0x04|`
3. **结构体整体对齐**：`MyStruct3` 中 `a` 的对齐要求是8字节，这是最大的对齐要求。当前成员占用 `4 (a) + 1 (b) = 5` 字节。为了使整个结构体大小是8的倍数，会在末尾填充3个字节。
   - 内存: `| a | a | a | a | b | P | P | P |`
   - 地址: `|0x00|0x01|0x02|0x03|0x04|0x05|0x06|0x07|`
   - 因此，`sizeof(MyStruct3)` 是 **8** 字节。`alignof(MyStruct3)` 也是 **8**。
   - `offsetof(MyStruct3, b)` 会是 **4**。

**内存布局分析 `MyStruct4`:**

1. `char b;`：占用1字节。起始地址 `0x00`。
   - 内存: `| b |`
2. `alignas(8) int a;`：`int` 大小4字节，对齐要求8字节。为了让 `a` 的起始地址是8的倍数，在 `b` 后面填充7个字节。
   - 内存: `| b | P | P | P | P | P | P | P | a | a | a | a |`
   - 地址: `|0x00| ... |0x07|0x08|0x09|0x0A|0x0B|`
   - `a` 的起始地址是 `0x08`。
3. **结构体整体对齐**：`MyStruct4` 中 `a` 的对齐要求是8字节。当前成员有效数据是 `1 (b) + 4 (a) = 5` 字节，但由于 `a` 的对齐，实际占用的内存到了 `0x0B` 之后，总共是12字节。因为结构体整体对齐要求是8，12不是8的倍数，所以需要填充到16。
   - 内存: `| b | P | P | P | P | P | P | P | a | a | a | a | P | P | P | P |`
   - 因此，`sizeof(MyStruct4)` 是 **16** 字节。`alignof(MyStruct4)` 是 **8**。
   - `offsetof(MyStruct4, a)` 会是 **8**。

**例4：使用 `#pragma pack(n)` (编译器特定)**

`#pragma pack(n)` 是一个预处理指令，用来告诉编译器采用指定的字节对齐方式。`n` 通常是1, 2, 4, 8, 16。

```cpp
#include <iostream>

#pragma pack(push, 1) // 设置按 1 字节对齐
struct MyStructPacked {
    char a;    // 1 字节
    int b;     // 4 字节
    short c;   // 2 字节
};
#pragma pack(pop) // 恢复之前的对齐方式

struct MyStructDefault {
    char a;
    int b;
    short c;
};

int main() {
    std::cout << "sizeof(MyStructPacked): " << sizeof(MyStructPacked) << std::endl;
    std::cout << "sizeof(MyStructDefault): " << sizeof(MyStructDefault) << std::endl;
    return 0;
}
```

**内存布局分析 `MyStructPacked` (使用 `#pragma pack(1)`):**

由于设置了1字节对齐，所有成员都会紧密排列，不会有任何padding。

1. `char a;`：1字节。
2. `int b;`：4字节，紧跟 `a`。
3. `short c;`：2字节，紧跟 `b`。

总大小 = `1 + 4 + 2 = 7` 字节。 所以 `sizeof(MyStructPacked)` 会是 **7**。

而 `sizeof(MyStructDefault)` 会和我们第一个例子 `MyStruct1` 一样，通常是 **12** 字节。

**注意：**

- `#pragma pack` 是编译器相关的，虽然主流编译器都支持，但不是C++标准的一部分。
- 过度使用 `#pragma pack(1)` 可能会牺牲性能，因为它可能导致非对齐内存访问。它通常用于需要与外部系统（如硬件接口、网络协议、文件格式）进行数据精确匹配的场景。