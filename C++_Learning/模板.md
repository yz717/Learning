- [模板](#模板)
  - [泛型编程](#泛型编程)
  - [函数模板](#函数模板)
  - [函数模板的原理](#函数模板的原理)
  - [函数模板的实例化](#函数模板的实例化)
    - [隐式实例化](#隐式实例化)
    - [显式实例化](#显式实例化)
  - [类模板](#类模板)
    - [类模板实例化的特点](#类模板实例化的特点)
  - [非类型模板参数](#非类型模板参数)
  - [模板特化](#模板特化)
    - [函数模板特化](#函数模板特化)
    - [类模板特化](#类模板特化)
  - [模板的分离编译问题](#模板的分离编译问题)
  - [模板总结](#模板总结)

# 模板

## 泛型编程

> 编写与类型无关的通用代码，是代码复用的一种手段。函数或类并不依赖于特定的数据类型，而是能够接受多种数据类型作为输入，从而在不同的类型上复用相同的代码。

泛型编程通常通过 **模板** 来实现，模板可以使程序员在编写代码时不必指定具体的类型，而是在编译时由编译器根据给定的类型来生成具体的实现。在 C++ 中，泛型编程的实现主要依赖于 **函数模板** 和 **类模板**。

## 函数模板

函数模板允许你定义一个函数，适用于多种不同的类型。在编写函数模板时，你可以使用占位符（模板参数）来代表函数的参数类型，而不需要提前指定具体的类型。编译器会根据实际传入的类型生成相应的函数版本。

**函数模板的基本语法**:

```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}
```

- `template <typename T>` 声明了一个模板，其中 `T` 是一个占位符类型参数，表示类型可以在调用时指定。
- `T add(T a, T b)` 是函数模板的定义，表示这个 `add` 函数能够接收任意类型的两个参数 `a` 和 `b`，并返回它们的和。

**注意**：`typename`是用来定义模板参数关键字，也可以使用`class`

## 函数模板的原理

利用 **模板机制**，在编译时根据函数调用的实际参数类型自动生成不同类型的函数版本。函数模板本身并不会在源代码中直接生成代码，而是在编译时根据类型信息生成相应的函数。

**函数模板并不会立即创建一个函数，而是作为一个“模板”存在**，它需要在调用时根据具体的类型实例化生成代码。

## 函数模板的实例化

用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：隐式实例化和显式实例化

### 隐式实例化

让编译器根据实参推演模板参数的实际类型

```cpp
template <typename T>
void Swap(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}

int main() {

	int a = 1, b = 2;
	Swap(a, b);//隐式实例化
	double c = 1.1, d = 2.2;
	Swap(c, d);//隐式实例化
    return 0;
}
```

### 显式实例化

在函数名后的`<>`中指定模板参数的实际类型 

```cpp
template <typename T>
void Swap(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}

int main() {

	int a = 1, b = 2;
	Swap<int>(a, b);//显式实例化
	double c = 1.1, d = 2.2;
	Swap<double>(c, d);//显式实例化
    return 0;
}
```

## 类模板

类模板定义的基本语法与函数模板相似。通过使用 `template` 关键字和类型参数来定义类模板。类型参数通常是占位符，代表希望在实际使用类模板时指定的类型。

```cpp
template <typename T>
class Box {
private:
    T value;  // 使用类型 T 定义成员变量
public:
    Box(T val) : value(val) {}  // 构造函数，初始化成员变量
    T getValue() { return value; }  // 返回成员变量的值
    void setValue(T val) { value = val; }  // 设置成员变量的值
};
```

### 类模板实例化的特点

- **函数模板实例化**是根据每次调用时传入的参数类型生成相应的函数代码。每次调用时，编译器都会生成一个特定类型的函数。

- **类模板实例化**是根据类型参数生成一个类的定义。生成的类是一个新类型，实例化后的类会在内存中占用空间，具有成员函数和成员变量。

- **函数模板实例化发生在函数调用时**，而**类模板实例化通常在声明对象时发生**。例如，`Vector<int> v1` 实际上是实例化了 `Vector` 类模板为 `Vector<int>`，而 `add(1, 2)` 是通过类型推导实例化了 `add<int>` 函数模板。

- **类模板名字不是真正的类，而实例化的结果才是真正的类**

  ```cpp
  Vector<int> v1;// Vextor类名，Vector<int>是一个具体的类
  Vector<double> v2;// Vector<double>是一个具体的类
  ```


## 非类型模板参数

模板参数不仅可以是类型，还可以是 **编译期常量**：

```cpp
template<class T, size_t N>
class Array {
private:
    T _array[N];
public:
    size_t size() const { return N; }
};
```

限制：

- 必须在编译期可确定。
- **不能是浮点数、对象、字符串字面量**。

##  模板特化

有时需要为某些类型提供 **特殊实现**，这叫模板特化。

### 函数模板特化

```cpp
template<class T>
bool IsEqual(const T& a, const T& b) {
    return a == b;
}

// 针对 char* 特化
template<>
bool IsEqual<const char*>(const char* a, const char* b) {
    return strcmp(a, b) == 0;
}
```

### 类模板特化

- **全特化**：所有参数都特化

  ```cpp
  template<class T1, class T2>
  class Data { /* 通用实现 */ };
  
  template<>
  class Data<int, char> {
      // 针对 int-char 的特殊实现
  };
  ```

- **偏特化**：部分参数特化，或增加条件限制

  ```cpp
  // 第二个参数固定为 int
  template<class T1>
  class Data<T1, int> { /* ... */ };
  
  // 参数为指针类型
  template<class T1, class T2>
  class Data<T1*, T2*> { /* ... */ };
  
  // 参数为引用类型
  template<class T1, class T2>
  class Data<T1&, T2&> { /* ... */ };
  ```

## 模板的分离编译问题

C++ 模板与普通函数/类不同，**定义与声明必须在同一文件**（通常写在 `.h` / `.hpp` 头文件）。
 如果只在 `.cpp` 中定义，会导致链接错误。

解决方法：

1. **定义和声明放在同一个头文件**（推荐）

   ```cpp
   // Add.hpp
   template<class T>
   T Add(const T& a, const T& b) {
       return a + b;
   }
   ```

2. 在 `.cpp` 中定义，并对需要的类型 **显式实例化**（不常用）。

   ```cpp
   template int Add<int>(const int&, const int&);
   template double Add<double>(const double&, const double&);
   ```

## 模板总结

**优点**

- 高度复用代码。
- 提升灵活性，支持多种数据类型。
- STL（标准模板库）就是基于模板实现的。

**缺点**

- **编译时间长**，会造成 **代码膨胀**。
- 出错时的 **错误信息复杂**，难以调试。